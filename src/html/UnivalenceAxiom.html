<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>UnivalenceAxiom</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Markup">::

</a>   <a id="8" class="Symbol">{-#</a> <a id="12" class="Keyword">OPTIONS</a> <a id="20" class="Pragma">--without-K</a> <a id="32" class="Pragma">--exact-split</a> <a id="46" class="Symbol">#-}</a>
   <a id="53" class="Keyword">open</a> <a id="58" class="Keyword">import</a> <a id="65" href="TransportLemmas.html" class="Module">TransportLemmas</a>
   <a id="84" class="Keyword">open</a> <a id="89" class="Keyword">import</a> <a id="96" href="EquivalenceType.html" class="Module">EquivalenceType</a>

   <a id="116" class="Keyword">open</a> <a id="121" class="Keyword">import</a> <a id="128" href="HomotopyType.html" class="Module">HomotopyType</a>
   <a id="144" class="Keyword">open</a> <a id="149" class="Keyword">import</a> <a id="156" href="FunExtAxiom.html" class="Module">FunExtAxiom</a>
   <a id="171" class="Keyword">open</a> <a id="176" class="Keyword">import</a> <a id="183" href="QuasiinverseType.html" class="Module">QuasiinverseType</a>
   <a id="203" class="Keyword">open</a> <a id="208" class="Keyword">import</a> <a id="215" href="QuasiinverseLemmas.html" class="Module">QuasiinverseLemmas</a>

<a id="235" class="Background">Voevodsky’s Univalence Axiom
----------------------------

Voevodsky’s Univalence axiom is postulated. It induces an equality
between any two equivalent types. Some :math:`β` and :math:`η` rules are
provided.

</a><a id="445" class="Markup">::

</a>   <a id="452" class="Keyword">module</a> <a id="459" href="UnivalenceAxiom.html" class="Module">UnivalenceAxiom</a> <a id="475" class="Symbol">{</a><a id="476" href="UnivalenceAxiom.html#476" class="Bound">ℓ</a> <a id="478" class="Symbol">:</a> <a id="480" href="Agda.Primitive.html#423" class="Postulate">Level</a><a id="485" class="Symbol">}</a> <a id="487" class="Symbol">{</a><a id="488" href="UnivalenceAxiom.html#488" class="Bound">A</a> <a id="490" href="UnivalenceAxiom.html#490" class="Bound">B</a> <a id="492" class="Symbol">:</a> <a id="494" href="Intro.html#1611" class="Function">Type</a> <a id="499" href="UnivalenceAxiom.html#476" class="Bound">ℓ</a><a id="500" class="Symbol">}</a> <a id="502" class="Keyword">where</a>

<a id="509" class="Markup">::

</a>     <a id="idtoeqv"></a><a id="518" href="UnivalenceAxiom.html#518" class="Function">idtoeqv</a>
       <a id="533" class="Symbol">:</a> <a id="535" href="UnivalenceAxiom.html#488" class="Bound">A</a> <a id="537" href="BasicTypes.html#9886" class="Datatype Operator">==</a> <a id="540" href="UnivalenceAxiom.html#490" class="Bound">B</a>
       <a id="549" class="Comment">--------</a>
       <a id="565" class="Symbol">→</a> <a id="567" href="UnivalenceAxiom.html#488" class="Bound">A</a> <a id="569" href="EquivalenceType.html#1378" class="Function Operator">≃</a> <a id="571" href="UnivalenceAxiom.html#490" class="Bound">B</a>

     <a id="579" href="UnivalenceAxiom.html#518" class="Function">idtoeqv</a> <a id="587" href="UnivalenceAxiom.html#587" class="Bound">p</a> <a id="589" class="Symbol">=</a>
       <a id="598" href="QuasiinverseType.html#3425" class="Function">qinv-≃</a>
         <a id="614" class="Symbol">(</a><a id="615" href="Transport.html#460" class="Function">coe</a> <a id="619" href="UnivalenceAxiom.html#587" class="Bound">p</a><a id="620" class="Symbol">)</a>
         <a id="631" class="Symbol">((</a><a id="633" href="Transport.html#608" class="Function">!coe</a> <a id="638" href="UnivalenceAxiom.html#587" class="Bound">p</a><a id="639" class="Symbol">)</a> <a id="641" href="BasicTypes.html#3548" class="InductiveConstructor Operator">,</a>
           <a id="654" class="Symbol">(</a><a id="655" href="TransportLemmas.html#5554" class="Function">coe-inv-l</a> <a id="665" href="UnivalenceAxiom.html#587" class="Bound">p</a> <a id="667" href="BasicTypes.html#3548" class="InductiveConstructor Operator">,</a> <a id="669" href="TransportLemmas.html#5769" class="Function">coe-inv-r</a> <a id="679" href="UnivalenceAxiom.html#587" class="Bound">p</a><a id="680" class="Symbol">))</a>

<a id="684" class="Background">More syntax:

</a><a id="698" class="Markup">::

</a>     <a id="==-to-≃"></a><a id="707" href="UnivalenceAxiom.html#707" class="Function">==-to-≃</a> <a id="715" class="Symbol">=</a> <a id="717" href="UnivalenceAxiom.html#518" class="Function">idtoeqv</a>
     <a id="≡-to-≃"></a><a id="730" href="UnivalenceAxiom.html#730" class="Function">≡-to-≃</a>  <a id="738" class="Symbol">=</a> <a id="740" href="UnivalenceAxiom.html#518" class="Function">idtoeqv</a>
     <a id="ite"></a><a id="753" href="UnivalenceAxiom.html#753" class="Function">ite</a>     <a id="761" class="Symbol">=</a> <a id="763" href="UnivalenceAxiom.html#518" class="Function">idtoeqv</a>
     <a id="cast"></a><a id="776" href="UnivalenceAxiom.html#776" class="Function">cast</a>    <a id="784" class="Symbol">=</a> <a id="786" href="UnivalenceAxiom.html#518" class="Function">idtoeqv</a>  <a id="795" class="Comment">-- Used in the Symmetry Book.</a>

<a id="826" class="Background">The **Univalence axiom** induces an equivalence between equalities and
equivalences.

Univalence Axiom.

</a><a id="931" class="Markup">::

</a>     <a id="940" class="Keyword">postulate</a>
       <a id="axiomUnivalence"></a><a id="957" href="UnivalenceAxiom.html#957" class="Postulate">axiomUnivalence</a>
         <a id="982" class="Symbol">:</a> <a id="984" href="EquivalenceType.html#1251" class="Function">isEquivalence</a> <a id="998" href="UnivalenceAxiom.html#730" class="Function">≡-to-≃</a>

<a id="1006" class="Background">In Slide 20 from an `Escardo’s
talk &lt;https://www.newton.ac.uk/files/seminar/20170711100011001-1442677.pdf&gt;`__,
base on what we saw, we give the following no standard definition of
Univalence axiom (without transport).

</a><a id="1225" class="Markup">::

</a>     <a id="1234" class="Keyword">open</a> <a id="1239" class="Keyword">import</a> <a id="1246" href="HLevelTypes.html" class="Module">HLevelTypes</a>

     <a id="UA"></a><a id="1264" href="UnivalenceAxiom.html#1264" class="Function">UA</a>
       <a id="1274" class="Symbol">:</a> <a id="1276" class="Symbol">∀</a> <a id="1278" class="Symbol">{</a><a id="1279" href="UnivalenceAxiom.html#1279" class="Bound">ℓ</a> <a id="1281" class="Symbol">:</a> <a id="1283" href="Agda.Primitive.html#423" class="Postulate">Level</a><a id="1288" class="Symbol">}</a>
       <a id="1297" class="Symbol">→</a> <a id="1299" class="Symbol">(</a><a id="1300" href="Intro.html#1611" class="Function">Type</a> <a id="1305" class="Symbol">(</a><a id="1306" href="Agda.Primitive.html#606" class="Primitive">lsuc</a> <a id="1311" href="UnivalenceAxiom.html#1279" class="Bound">ℓ</a><a id="1312" class="Symbol">))</a>

     <a id="1321" href="UnivalenceAxiom.html#1264" class="Function">UA</a> <a id="1324" class="Symbol">{</a><a id="1325" class="Argument">ℓ</a> <a id="1327" class="Symbol">=</a> <a id="1329" href="UnivalenceAxiom.html#1329" class="Bound">ℓ</a><a id="1330" class="Symbol">}</a>  <a id="1333" class="Symbol">=</a> <a id="1335" class="Symbol">(</a><a id="1336" href="UnivalenceAxiom.html#1336" class="Bound">X</a> <a id="1338" class="Symbol">:</a> <a id="1340" href="Intro.html#1611" class="Function">Type</a> <a id="1345" href="UnivalenceAxiom.html#1329" class="Bound">ℓ</a><a id="1346" class="Symbol">)</a> <a id="1348" class="Symbol">→</a> <a id="1350" href="HLevelTypes.html#465" class="Function">isContr</a> <a id="1358" class="Symbol">(</a><a id="1359" href="BasicTypes.html#3403" class="Record">∑</a> <a id="1361" class="Symbol">(</a><a id="1362" href="Intro.html#1611" class="Function">Type</a> <a id="1367" href="UnivalenceAxiom.html#1329" class="Bound">ℓ</a><a id="1368" class="Symbol">)</a> <a id="1370" class="Symbol">(λ</a> <a id="1373" href="UnivalenceAxiom.html#1373" class="Bound">Y</a> <a id="1375" class="Symbol">→</a> <a id="1377" class="Symbol">(</a><a id="1378" href="UnivalenceAxiom.html#1336" class="Bound">X</a> <a id="1380" href="EquivalenceType.html#1378" class="Function Operator">≃</a> <a id="1382" href="UnivalenceAxiom.html#1373" class="Bound">Y</a><a id="1383" class="Symbol">)))</a>

<a id="1388" class="Background">About this Univalence axiom version:

-  ∑ (Type ℓ) (λ Y → X ≃ Y) is inhabited, but we don’t know if it’s
   contractible unless, we demand (assume) to be propositional. Then, in
   such a case, we use the theorem (isProp P ≃ (P → isContr P)). To be
   more precise, we know it’s contractible, in fact, the center of
   contractibility, is indeed (X, id-≃ X : X ≃ X).

-  Univalence is a generalized extensionality axiom for intensional MLTT
   theory.

-  The type UA is a proposition.

-  UA is consistent with MLTT.

-  Theorem of MLTT+UA: :math:`P(X)` and :math:`X≃Y` imply :math:`P(Y)`
   for any :math:`P : \mathsf{Type} → \mathsf{Type}`.

-  Theorem of spartan MLTT with two universes. The univalence axiom
   formulated with crude isomorphism rather than equivalence is false!.

</a><a id="2175" class="Markup">::

</a>     <a id="eqvUnivalence"></a><a id="2184" href="UnivalenceAxiom.html#2184" class="Function">eqvUnivalence</a>
       <a id="2205" class="Symbol">:</a> <a id="2207" class="Symbol">(</a><a id="2208" href="UnivalenceAxiom.html#488" class="Bound">A</a> <a id="2210" href="BasicTypes.html#9886" class="Datatype Operator">==</a> <a id="2213" href="UnivalenceAxiom.html#490" class="Bound">B</a><a id="2214" class="Symbol">)</a> <a id="2216" href="EquivalenceType.html#1378" class="Function Operator">≃</a> <a id="2218" class="Symbol">(</a><a id="2219" href="UnivalenceAxiom.html#488" class="Bound">A</a> <a id="2221" href="EquivalenceType.html#1378" class="Function Operator">≃</a> <a id="2223" href="UnivalenceAxiom.html#490" class="Bound">B</a><a id="2224" class="Symbol">)</a>

     <a id="2232" href="UnivalenceAxiom.html#2184" class="Function">eqvUnivalence</a> <a id="2246" class="Symbol">=</a> <a id="2248" href="UnivalenceAxiom.html#518" class="Function">idtoeqv</a> <a id="2256" href="BasicTypes.html#3548" class="InductiveConstructor Operator">,</a> <a id="2258" href="UnivalenceAxiom.html#957" class="Postulate">axiomUnivalence</a>

<a id="2275" class="Background">More syntax:

</a><a id="2289" class="Markup">::

</a>     <a id="==-equiv-≃"></a><a id="2298" href="UnivalenceAxiom.html#2298" class="Function">==-equiv-≃</a> <a id="2309" class="Symbol">=</a> <a id="2311" href="UnivalenceAxiom.html#2184" class="Function">eqvUnivalence</a>
     <a id="==-≃-≃"></a><a id="2330" href="UnivalenceAxiom.html#2330" class="Function">==-≃-≃</a>     <a id="2341" class="Symbol">=</a> <a id="2343" href="UnivalenceAxiom.html#2184" class="Function">eqvUnivalence</a>
     <a id="≡-≃-≃"></a><a id="2362" href="UnivalenceAxiom.html#2362" class="Function">≡-≃-≃</a>      <a id="2373" class="Symbol">=</a> <a id="2375" href="UnivalenceAxiom.html#2184" class="Function">eqvUnivalence</a>

<a id="2390" class="Background">Introduction rule for equalities:

</a><a id="2425" class="Markup">::

</a>     <a id="ua"></a><a id="2434" href="UnivalenceAxiom.html#2434" class="Function">ua</a>
       <a id="2444" class="Symbol">:</a> <a id="2446" href="UnivalenceAxiom.html#488" class="Bound">A</a> <a id="2448" href="EquivalenceType.html#1378" class="Function Operator">≃</a> <a id="2450" href="UnivalenceAxiom.html#490" class="Bound">B</a>
       <a id="2459" class="Comment">-------</a>
       <a id="2474" class="Symbol">→</a> <a id="2476" href="UnivalenceAxiom.html#488" class="Bound">A</a> <a id="2478" href="BasicTypes.html#9886" class="Datatype Operator">==</a> <a id="2481" href="UnivalenceAxiom.html#490" class="Bound">B</a>

     <a id="2489" href="UnivalenceAxiom.html#2434" class="Function">ua</a> <a id="2492" class="Symbol">=</a> <a id="2494" href="EquivalenceType.html#1799" class="Function">remap</a> <a id="2500" href="UnivalenceAxiom.html#2184" class="Function">eqvUnivalence</a>

<a id="2515" class="Background">More syntax:

</a><a id="2529" class="Markup">::

</a>     <a id="≃-to-=="></a><a id="2538" href="UnivalenceAxiom.html#2538" class="Function">≃-to-==</a>   <a id="2548" class="Symbol">=</a> <a id="2550" href="UnivalenceAxiom.html#2434" class="Function">ua</a>
     <a id="eqv-to-eq"></a><a id="2558" href="UnivalenceAxiom.html#2558" class="Function">eqv-to-eq</a> <a id="2568" class="Symbol">=</a> <a id="2570" href="UnivalenceAxiom.html#2434" class="Function">ua</a>

<a id="2574" class="Background">Computation rules

</a><a id="2593" class="Markup">::

</a>     <a id="ua-β"></a><a id="2602" href="UnivalenceAxiom.html#2602" class="Function">ua-β</a>
       <a id="2614" class="Symbol">:</a> <a id="2616" class="Symbol">(</a><a id="2617" href="UnivalenceAxiom.html#2617" class="Bound">α</a> <a id="2619" class="Symbol">:</a> <a id="2621" href="UnivalenceAxiom.html#488" class="Bound">A</a> <a id="2623" href="EquivalenceType.html#1378" class="Function Operator">≃</a> <a id="2625" href="UnivalenceAxiom.html#490" class="Bound">B</a><a id="2626" class="Symbol">)</a>
       <a id="2635" class="Comment">----------------------</a>
       <a id="2665" class="Symbol">→</a> <a id="2667" href="UnivalenceAxiom.html#518" class="Function">idtoeqv</a> <a id="2675" class="Symbol">(</a><a id="2676" href="UnivalenceAxiom.html#2434" class="Function">ua</a> <a id="2679" href="UnivalenceAxiom.html#2617" class="Bound">α</a><a id="2680" class="Symbol">)</a> <a id="2682" href="BasicTypes.html#9886" class="Datatype Operator">==</a> <a id="2685" href="UnivalenceAxiom.html#2617" class="Bound">α</a>

     <a id="2693" href="UnivalenceAxiom.html#2602" class="Function">ua-β</a> <a id="2698" href="UnivalenceAxiom.html#2698" class="Bound">eqv</a> <a id="2702" class="Symbol">=</a> <a id="2704" href="EquivalenceType.html#2076" class="Function">lrmap-inverse</a> <a id="2718" href="UnivalenceAxiom.html#2184" class="Function">eqvUnivalence</a>

<a id="2733" class="Markup">::

</a>     <a id="ua-η"></a><a id="2742" href="UnivalenceAxiom.html#2742" class="Function">ua-η</a>
       <a id="2754" class="Symbol">:</a> <a id="2756" class="Symbol">(</a><a id="2757" href="UnivalenceAxiom.html#2757" class="Bound">p</a> <a id="2759" class="Symbol">:</a> <a id="2761" href="UnivalenceAxiom.html#488" class="Bound">A</a> <a id="2763" href="BasicTypes.html#9886" class="Datatype Operator">==</a> <a id="2766" href="UnivalenceAxiom.html#490" class="Bound">B</a><a id="2767" class="Symbol">)</a>
       <a id="2776" class="Comment">---------------------</a>
       <a id="2805" class="Symbol">→</a> <a id="2807" href="UnivalenceAxiom.html#2434" class="Function">ua</a> <a id="2810" class="Symbol">(</a><a id="2811" href="UnivalenceAxiom.html#518" class="Function">idtoeqv</a> <a id="2819" href="UnivalenceAxiom.html#2757" class="Bound">p</a><a id="2820" class="Symbol">)</a> <a id="2822" href="BasicTypes.html#9886" class="Datatype Operator">==</a> <a id="2825" href="UnivalenceAxiom.html#2757" class="Bound">p</a>

     <a id="2833" href="UnivalenceAxiom.html#2742" class="Function">ua-η</a> <a id="2838" href="UnivalenceAxiom.html#2838" class="Bound">p</a> <a id="2840" class="Symbol">=</a> <a id="2842" href="EquivalenceType.html#2282" class="Function">rlmap-inverse</a> <a id="2856" href="UnivalenceAxiom.html#2184" class="Function">eqvUnivalence</a>
</pre></body></html>